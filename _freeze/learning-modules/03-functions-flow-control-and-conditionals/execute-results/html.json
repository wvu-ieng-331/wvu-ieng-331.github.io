{
  "hash": "cfd51091f6bc4edadb59f6afc09dbab5",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"03 | Functions, Flow Control, & Conditionals\"\nsubtitle: \"Designing Reusable Code, Looping, & Decision Making\"\nformat: html\norder: 3\n---\n\n\n\n\n## Overview\n\nSo far, we’ve used Python’s built-in functions. In this module, you’ll learn to create and run your own functions, and see how one function can call another. We’ll also introduce the `for` loop to repeat computations and the if statement to execute different code based on program state. Finally, we’ll learn how to handle external files, update variables, and perform searches in strings.\n\n## Defining new functions\n\nA **function definition** specifies the name of a new function and the sequence of statements that run when the function is called:\n\n::: {#59cc12ad .cell execution_count=1}\n``` {.python .cell-code}\ndef print_lyrics():\n    print(\"Almost Heaven, West Virginia\")\n    print(\"Blue Ridge Mountains, Shenandoah River\")\n```\n:::\n\n\n`def` is a keyword that indicates a function definition. The name of this function is `print_lyrics`. The empty parentheses after the name indicate that this function doesn't take any arguments.\n\nThe first line of the function definition is the **header**, and the rest is the **body**. The header must end with a colon, and the body must be indented (by convention, four spaces). The body of this function is two `print()` statements, but in general, the body can include any number of statements.\n\nDefining a function creates a **function object**, which you can display:\n\n::: {#2f3d8052 .cell execution_count=2}\n``` {.python .cell-code}\nprint_lyrics\n```\n\n::: {.cell-output .cell-output-display execution_count=56}\n```\n<function __main__.print_lyrics()>\n```\n:::\n:::\n\n\nThe output shows that `print_lyrics` takes no arguments. `__main__` is the name of the module that contains `print_lyrics`.\n\nYou can call this function the same way as any other Python function:\n\n::: {#abdfd027 .cell execution_count=3}\n``` {.python .cell-code}\nprint_lyrics()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAlmost Heaven, West Virginia\nBlue Ridge Mountains, Shenandoah River\n```\n:::\n:::\n\n\n## Parameters\n\nSome of the functions we've seen require arguments: `abs()` takes a number, and `math.pow()` takes two arguments (the base and the exponent). We can make our own:\n\n::: {#26437f4d .cell execution_count=4}\n``` {.python .cell-code}\ndef print_twice(string):\n    print(string)\n    print(string)\n```\n:::\n\n\nThe variable in parentheses is called a **parameter**. When the function is called, the value of the argument is assigned to the parameter. For example:\n\n::: {#105edaf2 .cell execution_count=5}\n``` {.python .cell-code}\nprint_twice(\"Hail WV!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHail WV!\nHail WV!\n```\n:::\n:::\n\n\nThis has the same effect as assigning the argument to the parameter and then executing the body:\n\n::: {#c5ce5a4f .cell execution_count=6}\n``` {.python .cell-code}\nstring = \"Hail WV!\"\nprint(string)\nprint(string)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHail WV!\nHail WV!\n```\n:::\n:::\n\n\nYou can also pass a variable as an argument:\n\n::: {#279e5db5 .cell execution_count=7}\n``` {.python .cell-code}\nline = \"Hail WV!\"\nprint_twice(line)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHail WV!\nHail WV!\n```\n:::\n:::\n\n\n## Calling functions\n\nOnce you define a function, you can use it inside another. Here’s a playful example of printing lyrics for [\"Turn Down For What\" by DJ Snake & Lil Jon](https://genius.com/Dj-snake-and-lil-jon-turn-down-for-what-lyrics):\n\n```\nVerse:\nFire up that loud\nAnother round of shots\n\nChorus:\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\n\nBuild:\nshots! shots! shots! shots!\nshots! shots! shots! shots!\nshots! shots! shots! shots!\nshots! shots! shots! shots!\n```\n\nAs Lil Jon suggests, we need to buy a lot of rounds of shots. We can start with a helper function:\n\n::: {#cbe88bc7 .cell execution_count=8}\n``` {.python .cell-code}\ndef repeat(word, n):\n    print(word * n)\n```\n:::\n\n\n::: {#35b94d4f .cell execution_count=9}\n``` {.python .cell-code}\nrepeat(\"shots! \", 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nshots! shots! shots! \n```\n:::\n:::\n\n\n::: {#64c62193 .cell execution_count=10}\n``` {.python .cell-code}\ndef print_build():\n    repeat(\"shots! \", 4)\n    repeat(\"shots! \", 4)\n    repeat(\"shots! \", 4)\n    repeat(\"shots! \", 4)\n\nprint_build()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \n```\n:::\n:::\n\n\n`print_build()` calls `repeat()`, which then calls `print()`. We could do the same with fewer functions, but this illustrates how functions can work together.\n\nIf we want to control how many times `repeat()` repeats, we add a parameter to `print_build()`:\n\n::: {#6a22d544 .cell execution_count=11}\n``` {.python .cell-code}\ndef print_build(n):\n    repeat(\"shots! \", n)\n    repeat(\"shots! \", n)\n    repeat(\"shots! \", n)\n    repeat(\"shots! \", n)\n```\n:::\n\n\nThen we can call:\n\n::: {#1af76f79 .cell execution_count=12}\n``` {.python .cell-code}\nprint_build(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \n```\n:::\n:::\n\n\nNext, let’s add verse and chorus functions:\n\n::: {#ec0205dc .cell execution_count=13}\n``` {.python .cell-code}\ndef print_verse():\n    print(\"Fire up that loud\")\n    print(\"Another round of shots\")\n\nprint_verse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFire up that loud\nAnother round of shots\n```\n:::\n:::\n\n\n::: {#2d9c7ce5 .cell execution_count=14}\n``` {.python .cell-code}\ndef print_chorus():\n    print(\"Turn down for what?\")\n    print(\"Turn down for what?\")\n    print(\"Turn down for what?\")\n    print(\"Turn down for what?\")\n    print(\"Turn down for what?\")\n\nprint_chorus()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\n```\n:::\n:::\n\n\nNow bring it all together:\n\n::: {#e148dcd1 .cell execution_count=15}\n``` {.python .cell-code}\nprint_verse()\nprint_chorus()\nprint_verse()\nprint_chorus()\nprint_build(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFire up that loud\nAnother round of shots\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\nFire up that loud\nAnother round of shots\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \n```\n:::\n:::\n\n\nWe’re repeating some lines of code explicitly, which isn’t ideal. We’ll address that soon.\n\n## Repetition\n\nTo print something multiple times, you can use a `for` loop. Here’s a simple example:\n\n::: {#1ce807b8 .cell execution_count=16}\n``` {.python .cell-code}\nfor i in range(2):\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1\n```\n:::\n:::\n\n\n`range(2)` creates a sequence of two values: `0` and `1`. The loop assigns each value to `i` and then runs the body. When the sequence ends, the loop ends.\n\nHere’s a loop that prints the verse twice:\n\n::: {#f8fda9ae .cell execution_count=17}\n``` {.python .cell-code}\nfor i in range(2):\n    print(\"Verse\", i)\n    print_verse(),\n    print() # adds a blank line\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVerse 0\nFire up that loud\nAnother round of shots\n\nVerse 1\nFire up that loud\nAnother round of shots\n\n```\n:::\n:::\n\n\nA `for` loop can appear inside a function, such as this one that prints the verse `m` times:\n\n::: {#2fb9ed1d .cell execution_count=18}\n``` {.python .cell-code}\ndef print_m_verse(m):\n    for i in range(m):\n        print_verse()\n\nprint_m_verse(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFire up that loud\nAnother round of shots\nFire up that loud\nAnother round of shots\nFire up that loud\nAnother round of shots\nFire up that loud\nAnother round of shots\n```\n:::\n:::\n\n\nIn this example, we don't use `i` in the body of the loop, but there has to be a variable in the header anyway.\n\n## Variables and parameters are local\n\nA variable created inside a function is **local**, meaning it only exists inside that function. Here’s an example:\n\n::: {#0408444c .cell execution_count=19}\n``` {.python .cell-code}\ndef cat_twice(part_1, part_2):\n    cat = part_1 + part_2\n    print_twice(cat)\n```\n:::\n\n\n::: {#b676a1da .cell execution_count=20}\n``` {.python .cell-code}\nline_1 = \"Country roads, \"\nline_2 = \"take me home.\"\ncat_twice(line_1, line_2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCountry roads, take me home.\nCountry roads, take me home.\n```\n:::\n:::\n\n\nInside `cat_twice()`, cat is created. Outside of it, `cat` doesn’t exist:\n\n::: {#3072b72d .cell execution_count=21}\n``` {.python .cell-code}\nprint(cat)\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg ansi-bold\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg ansi-bold\">NameError</span>                                 Traceback (most recent call last)\nCell <span class=\"ansi-green-fg ansi-bold\">In[75], line 1</span>\n<span class=\"ansi-green-fg ansi-bold\">----&gt; 1</span> <span style=\"color:rgb(0,135,0)\">print</span>(<span class=\"ansi-yellow-bg\">cat</span>)\n\n<span class=\"ansi-red-fg ansi-bold\">NameError</span>: name 'cat' is not defined</pre>\n```\n:::\n\n:::\n:::\n\n\nParameters are also local. Outside `cat_twice()`, `part_1` and `part_2` don’t exist.\n\n## Tracebacks\n\nWhen a runtime error occurs inside a function, Python shows a **traceback**, listing the function that was running, the function that called it, and so on, up the “stack.” Here’s a `print_twice()` that tries to print `cat`, which is a local variable in a different function:\n\n::: {#7efc50a9 .cell execution_count=22}\n``` {.python .cell-code}\ndef print_twice(string):\n    print(cat)              # NameError\n    print(cat)\n```\n:::\n\n\n::: {#1df128a6 .cell execution_count=23}\n``` {.python .cell-code}\ncat_twice(line_1, line_2)\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg ansi-bold\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg ansi-bold\">NameError</span>                                 Traceback (most recent call last)\nCell <span class=\"ansi-green-fg ansi-bold\">In[77], line 1</span>\n<span class=\"ansi-green-fg ansi-bold\">----&gt; 1</span> <span class=\"ansi-yellow-bg\">cat_twice</span><span class=\"ansi-yellow-bg\">(</span><span class=\"ansi-yellow-bg\">line_1</span><span class=\"ansi-yellow-bg\">,</span><span class=\"ansi-yellow-bg\"> </span><span class=\"ansi-yellow-bg\">line_2</span><span class=\"ansi-yellow-bg\">)</span>\n\nCell <span class=\"ansi-green-fg ansi-bold\">In[73], line 3</span>, in <span class=\"ansi-cyan-fg\">cat_twice</span><span class=\"ansi-blue-fg ansi-bold\">(part_1, part_2)</span>\n<span class=\"ansi-green-fg\">      1</span> <span style=\"font-weight:bold;color:rgb(0,135,0)\">def</span><span style=\"color:rgb(188,188,188)\"> </span><span style=\"color:rgb(0,0,255)\">cat_twice</span>(part_1, part_2):\n<span class=\"ansi-green-fg\">      2</span>     cat <span style=\"color:rgb(98,98,98)\">=</span> part_1 <span style=\"color:rgb(98,98,98)\">+</span> part_2\n<span class=\"ansi-green-fg ansi-bold\">----&gt; 3</span>     <span class=\"ansi-yellow-bg\">print_twice</span><span class=\"ansi-yellow-bg\">(</span><span class=\"ansi-yellow-bg\">cat</span><span class=\"ansi-yellow-bg\">)</span>\n\nCell <span class=\"ansi-green-fg ansi-bold\">In[76], line 2</span>, in <span class=\"ansi-cyan-fg\">print_twice</span><span class=\"ansi-blue-fg ansi-bold\">(string)</span>\n<span class=\"ansi-green-fg\">      1</span> <span style=\"font-weight:bold;color:rgb(0,135,0)\">def</span><span style=\"color:rgb(188,188,188)\"> </span><span style=\"color:rgb(0,0,255)\">print_twice</span>(string):\n<span class=\"ansi-green-fg ansi-bold\">----&gt; 2</span>     <span style=\"color:rgb(0,135,0)\">print</span>(<span class=\"ansi-yellow-bg\">cat</span>)              <span style=\"font-style:italic;color:rgb(95,135,135)\"># NameError</span>\n<span class=\"ansi-green-fg\">      3</span>     <span style=\"color:rgb(0,135,0)\">print</span>(cat)\n\n<span class=\"ansi-red-fg ansi-bold\">NameError</span>: name 'cat' is not defined</pre>\n```\n:::\n\n:::\n:::\n\n\nThe traceback shows that `cat_twice()` called `print_twice()`, which caused the error.\n\n## Refactoring\n\nLet’s reorganize our \"Turn Down for What\" example to avoid repeated code. This is called **refactoring**.\n\n::: {#f12de1cf .cell execution_count=24}\n``` {.python .cell-code}\n# Original\ndef print_build(n):\n    repeat(\"shots! \", n)\n    repeat(\"shots! \", n)\n    repeat(\"shots! \", n)\n    repeat(\"shots! \", n)\n\n# Improved\ndef print_build(repeats, shots):\n    for i in range(repeats):\n        repeat(\"shots! \", shots)\n\nprint_build(4, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \n```\n:::\n:::\n\n\n::: {#698d3dd4 .cell execution_count=25}\n``` {.python .cell-code}\n# Original\ndef print_verse():\n    print(\"Fire up that loud\")\n    print(\"Another round of shots\")\n\n# Improved\ndef print_verse(lines):\n    for i in range(lines):\n        print(\"Fire up that loud\")\n        print(\"Another round of shots\")\n\nprint_verse(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFire up that loud\nAnother round of shots\nFire up that loud\nAnother round of shots\nFire up that loud\nAnother round of shots\nFire up that loud\nAnother round of shots\n```\n:::\n:::\n\n\n::: {#be5fd9b3 .cell execution_count=26}\n``` {.python .cell-code}\n# Original\ndef print_chorus():\n    print(\"Turn down for what?\")\n    print(\"Turn down for what?\")\n    print(\"Turn down for what?\")\n    print(\"Turn down for what?\")\n    print(\"Turn down for what?\")\n\n# Improved\ndef print_chorus(lines):\n    for i in range(lines):\n        print(\"Turn down for what?\")\n\nprint_chorus(6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\n```\n:::\n:::\n\n\nPutting it all together:\n\n::: {#8fb77dff .cell execution_count=27}\n``` {.python .cell-code}\nprint_verse(1)\nprint()\nprint_chorus(5)\nprint()\nprint_verse(1)\nprint()\nprint_chorus(5)\nprint()\nprint_verse(4)\nprint()\nprint_build(6, 4)\nprint()\nprint_chorus(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFire up that loud\nAnother round of shots\n\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\n\nFire up that loud\nAnother round of shots\n\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\n\nFire up that loud\nAnother round of shots\nFire up that loud\nAnother round of shots\nFire up that loud\nAnother round of shots\nFire up that loud\nAnother round of shots\n\nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \n\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\n```\n:::\n:::\n\n\nRefactoring improves the code’s structure without changing its behavior. If we had planned the structure from the start, we might have avoided this step, but sometimes you only see a better design after you start coding.\n\n## Why functions?\n\n- **Readability**: Naming groups of statements makes code easier to read and debug.\n- **Reusability**: Functions eliminate repetitive code. Changes become easier to manage.\n- **Modularity**: Breaking down a program into functions lets you debug parts individually.\n- **Reuse**: Well-designed functions can be used by other programs.\n\nWrapping code in a function is called **encapsulation**. One advantage is that a name serves as documentation. Another is that calling a function is more concise than copying and pasting its body.\n\nAdding parameters to a function is called **generalization**, because it makes the function more general – for example, printing `\"shots!\"` any number of times.\n\nWhen a function has several numerical arguments, it’s easy to mix them up. You can use **keyword arguments** to specify each argument by name:\n\n::: {#c22cad79 .cell execution_count=28}\n``` {.python .cell-code}\ndef print_build(repeats, shots):\n    for i in range(repeats):\n        repeat(\"shots! \", shots)\n\nprint_build(repeats=8, shots=4)\nprint()\nprint_build(shots=4, repeats=8)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \n\nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \n```\n:::\n:::\n\n\n## Docstrings\n\nA **docstring** is a string at the start of a function that explains its interface:\n\n::: {#2f08343e .cell execution_count=29}\n``` {.python .cell-code}\ndef print_build(repeats, shots):\n    \"\"\"Prints \"shots\" for a custom amount of times and lines\n\n    repeats: number of lines of lyrics\n    shots: number of times \"shots\" is printed per line\n    \"\"\"\n    for i in range(repeats):\n        repeat(\"shots! \", shots)\n```\n:::\n\n\nA good docstring explains what the function does and the effect of each parameter, without diving into internal details.\n\n## `if` statements\n\n**Conditional statements** let you check conditions and change the program’s behavior. The simplest form is the `if` statement:\n\n```{.python}\nif x > 0:\n    print('x is positive')\n```\n\nThe boolean expression after `if` is called the condition. If it’s true, Python executes the indented block; otherwise, it skips it.\n\nIf you need a block that does nothing, use `pass`:\n\n```{.python}\nif x < 0:\n    pass          # TODO: need to handle negative values!\n```\n\n## Boolean expressions and logical operators\n\nA boolean expression is either `True` or `False`. For instance:\n\n::: {#d8916596 .cell execution_count=30}\n``` {.python .cell-code}\n5 == 5\n```\n\n::: {.cell-output .cell-output-display execution_count=84}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#c6967e4f .cell execution_count=31}\n``` {.python .cell-code}\n5 == 7\n```\n\n::: {.cell-output .cell-output-display execution_count=85}\n```\nFalse\n```\n:::\n:::\n\n\nThe double equal sign `==` compares two values for equality.\n\n::: {.callout-tip}\nA common error is to use a single equal sign (`=`) instead of a double equal sign (`==`). Remember that `=` assigns a value to a variable and `==` compares two values.\n:::\n\nOther relational operators include:\n\n```{.python}\nx != y # x is not equal to y\nx > y  # x is greater than y\nx < y  # x is less than to y\nx >= y # x is greater than or equal to y\nx <= y # x is less than or equal to y\n```\n\nYou can combine boolean expressions with **logical operators**: `and`, `or`, and `not`. For example:\n\n```{.python}\nx > 0 and x < 10\nx % 2 == 0 or x % 3 == 0\nnot x > y\n```\n\n## The `else` clause \n\n`if` can include an `else` clause:\n\n```{.python}\nif x % 2 == 0:\n    print('x is even')\nelse:\n    print('x is odd')\n```\n\nOne branch runs if the condition is true, the other if it’s false.\n\n## Chained conditionals\n\nWhen you have more than two possibilities, use `elif`:\n\n```{.python}\nif x < y:\n    print('x is less than y')\nelif x > y:\n    print('x is greater than y')\nelse:\n    print('x and y are equal')\n```\n\nConditions are checked in order, and only the first true branch runs.\n\n## Nested Conditionals\n\nOne conditional can be nested within another, but it can be harder to read:\n\n```{.python}\nif 0 < x:\n    if x < 10:\n        print('x is a positive single-digit number.')\n```\n\nLogical operators often simplify nested conditionals:\n\n```{.python}\nif 0 < x and x < 10:\n    print('x is a positive single-digit number.')\n```\n\nFor this kind of condition, Python provides a more concise option:\n\n```{.python}\nif 0 < x < 10:\n    print('x is a positive single-digit number.')\n```\n\n## Some functions have return values\n\nFunctions like `abs`, `round`, `math.sqrt`, and `math.pow` return a value. You can assign that value to a variable or use it in an expression:\n\n::: {#93a7daaa .cell execution_count=32}\n``` {.python .cell-code}\nimport math\nradius = math.sqrt(42 / math.pi)\narea = math.pi * radius**2\n```\n:::\n\n\nYou can also write your own function with a return value:\n\n::: {#08c50190 .cell execution_count=33}\n``` {.python .cell-code}\ndef circle_area(radius):\n    area = math.pi * radius**2\n    return area\n```\n:::\n\n\n::: {#9d41a04b .cell execution_count=34}\n``` {.python .cell-code}\na = circle_area(radius)\na\n```\n\n::: {.cell-output .cell-output-display execution_count=88}\n```\n42.00000000000001\n```\n:::\n:::\n\n\nHowever, local variables inside a function (like `area`) don’t exist outside that function.\n\n::: {#9594a1bb .cell execution_count=35}\n``` {.python .cell-code}\narea\n```\n\n::: {.cell-output .cell-output-display execution_count=89}\n```\n42.00000000000001\n```\n:::\n:::\n\n\n## And some have `None`\n\nIf a function doesn’t use `return`, it returns `None`, a special value:\n\n::: {#d1807af5 .cell execution_count=36}\n``` {.python .cell-code}\ndef repeat(word, n):\n    print(word * n)\n```\n:::\n\n\nThis function uses the `print` function to display a string, but it does not use a `return` statement to return a value. If we assign the result to a variable, it displays the string anyway.\n\n::: {#82154596 .cell execution_count=37}\n``` {.python .cell-code}\nresult = repeat('Shots! ', 3)\nprint(result)  # Displays None\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nShots! Shots! Shots! \nNone\n```\n:::\n:::\n\n\nIf you want a function that returns a string rather than prints it, you can do:\n\n::: {#67fc61eb .cell execution_count=38}\n``` {.python .cell-code}\ndef repeat_string(word, n):\n    return word * n\n```\n:::\n\n\nNotice that we can use an expression in a return statement, not just a variable.\n\n## Return values and conditionals\n\nA function can have multiple return statements, such as a reimplementation of `abs`:\n\n::: {#94f514e5 .cell execution_count=39}\n``` {.python .cell-code}\ndef absolute_value(x):\n    if x < 0:\n        return -x\n    else:\n        return x\n```\n:::\n\n\nMake sure thath every possible path hits a return statement:\n\n::: {#f667c126 .cell execution_count=40}\n``` {.python .cell-code}\ndef absolute_value_wrong(x):\n    if x < 0:\n        return -x\n    if x > 0:\n        return x\n    # If x is 0, returns None (missing a final else branch)\n```\n:::\n\n\n## Boolean functions\n\nFunctions can return the boolean values `True` and `False`, which is often convenient for encapsulating a complex test in a function. For example, `is_divisible` checks whether x is divisible by y with no remainder.\n\n::: {#120f483c .cell execution_count=41}\n``` {.python .cell-code}\ndef is_divisible(x, y):\n    if x % y == 0:\n        return True\n    else:\n        return False\n```\n:::\n\n\n::: {#7f21d732 .cell execution_count=42}\n``` {.python .cell-code}\nis_divisible(6, 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=96}\n```\nFalse\n```\n:::\n:::\n\n\n::: {#3ba73747 .cell execution_count=43}\n``` {.python .cell-code}\nis_divisible(6, 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=97}\n```\nTrue\n```\n:::\n:::\n\n\nInside the function, the result of the `==` operator is a boolean, so we can write the function more concisely by returning it directly:\n\n::: {#7e3b88e7 .cell execution_count=44}\n``` {.python .cell-code}\ndef is_divisible(x, y):\n    return x % y == 0\n```\n:::\n\n\nBoolean functions are often used in conditional statements:\n\n::: {#6cd428e5 .cell execution_count=45}\n``` {.python .cell-code}\nif is_divisible(6, 2):\n    print('divisible')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndivisible\n```\n:::\n:::\n\n\nIt might be tempting to write something like this:\n\n::: {#124a5848 .cell execution_count=46}\n``` {.python .cell-code}\nif is_divisible(6, 2) == True:\n    print('divisible')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndivisible\n```\n:::\n:::\n\n\nBut the comparison is unnecessary.\n\n## Input validation\n\nWe now have all the tools we need to make sure that the programs we write will be executed fully, regardless of user error.\n\nRemember, if the end use can mess up your instructions they will. Sound familiar?\n\nLet's go back to the example of calculating the volume of a sphere with a succinct function using what we've learned so far:\n\n::: {#d6409413 .cell execution_count=47}\n``` {.python .cell-code}\ndef volume_of_sphere(radius):\n    from math import pi\n    return (4/3) * pi * radius**3\n```\n:::\n\n\nIf radius is an integer or float, no problem. But if we get a string, we will get an error:\n\n::: {#661612ac .cell execution_count=48}\n``` {.python .cell-code}\nprint(volume_of_sphere(4))\nprint(volume_of_sphere(\"4\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n268.082573106329\n```\n:::\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg ansi-bold\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg ansi-bold\">TypeError</span>                                 Traceback (most recent call last)\nCell <span class=\"ansi-green-fg ansi-bold\">In[102], line 2</span>\n<span class=\"ansi-green-fg\">      1</span> <span style=\"color:rgb(0,135,0)\">print</span>(volume_of_sphere(<span style=\"color:rgb(98,98,98)\">4</span>))\n<span class=\"ansi-green-fg ansi-bold\">----&gt; 2</span> <span style=\"color:rgb(0,135,0)\">print</span>(<span class=\"ansi-yellow-bg\">volume_of_sphere</span><span class=\"ansi-yellow-bg\">(</span><span style=\"color:rgb(175,0,0)\" class=\"ansi-yellow-bg\">\"</span><span style=\"color:rgb(175,0,0)\" class=\"ansi-yellow-bg\">4</span><span style=\"color:rgb(175,0,0)\" class=\"ansi-yellow-bg\">\"</span><span class=\"ansi-yellow-bg\">)</span>)\n\nCell <span class=\"ansi-green-fg ansi-bold\">In[101], line 3</span>, in <span class=\"ansi-cyan-fg\">volume_of_sphere</span><span class=\"ansi-blue-fg ansi-bold\">(radius)</span>\n<span class=\"ansi-green-fg\">      1</span> <span style=\"font-weight:bold;color:rgb(0,135,0)\">def</span><span style=\"color:rgb(188,188,188)\"> </span><span style=\"color:rgb(0,0,255)\">volume_of_sphere</span>(radius):\n<span class=\"ansi-green-fg\">      2</span>     <span style=\"font-weight:bold;color:rgb(0,135,0)\">from</span><span style=\"color:rgb(188,188,188)\"> </span><span style=\"font-weight:bold;color:rgb(0,0,255)\">math</span><span style=\"color:rgb(188,188,188)\"> </span><span style=\"font-weight:bold;color:rgb(0,135,0)\">import</span> pi\n<span class=\"ansi-green-fg ansi-bold\">----&gt; 3</span>     <span style=\"font-weight:bold;color:rgb(0,135,0)\">return</span> (<span style=\"color:rgb(98,98,98)\">4</span><span style=\"color:rgb(98,98,98)\">/</span><span style=\"color:rgb(98,98,98)\">3</span>) <span style=\"color:rgb(98,98,98)\">*</span> pi <span style=\"color:rgb(98,98,98)\">*</span> <span class=\"ansi-yellow-bg\">radius</span><span style=\"color:rgb(98,98,98)\" class=\"ansi-yellow-bg\">*</span><span style=\"color:rgb(98,98,98)\" class=\"ansi-yellow-bg\">*</span><span style=\"color:rgb(98,98,98)\" class=\"ansi-yellow-bg\">3</span>\n\n<span class=\"ansi-red-fg ansi-bold\">TypeError</span>: unsupported operand type(s) for ** or pow(): 'str' and 'int'</pre>\n```\n:::\n\n:::\n:::\n\n\nWhile the default error message gives the user an idea of what's wrong, we can handle this more gracefully:\n\n::: {#44c387ef .cell execution_count=49}\n``` {.python .cell-code}\ndef volume_of_sphere(radius):\n    if type(radius) == int or type(radius) == float:\n        from math import pi\n        return (4/3) * pi * radius**3\n    else:\n        print(\"Input was not a number, try again.\")\n        return None\n\nvolume_of_sphere(\"5\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInput was not a number, try again.\n```\n:::\n:::\n\n\nIf this were a standalone program, it would return a result instead of stopping execution with an error.\n\n## Debugging\n\nDebugging can be frustrating, but it is also challenging, interesting, and sometimes even fun. And it is one of the most important skills you can learn.\n\nIn some ways debugging is like detective work. You are given clues and you have to infer the events that led to the results you see.\n\nDebugging is also like experimental science. Once you have an idea about what is going wrong, you modify your program and try again. If your hypothesis was correct, you can predict the result of the modification, and you take a step closer to a working program. If your hypothesis was wrong, you have to come up with a new one.\n\nFor some people, programming and debugging are the same thing; that is, programming is the process of gradually debugging a program until it does what you want. The idea is that you should start with a working program and make small modifications, debugging them as you go.\n\nIf you find yourself spending a lot of time debugging, that is often a sign that you are writing too much code before you start tests. If you take smaller steps, you might find that you can move faster.\n\n---\n\nWhen a syntax or runtime error occurs, the error message contains a lot of information, but it can be overwhelming. The most useful parts are usually:\n\n- What kind of error it was, and\n- Where it occurred.\n\nSyntax errors are usually easy to find, but there are a few gotchas. Errors related to spaces and tabs can be tricky because they are invisible and we are used to ignoring them.\n\n::: {#de835c96 .cell execution_count=50}\n``` {.python .cell-code}\nx = 5\n y = 6\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-cyan-fg ansi-bold\">  Cell </span><span class=\"ansi-green-fg ansi-bold\">In[104], line 2</span>\n<span class=\"ansi-yellow-fg ansi-bold\">    y = 6</span>\n<span class=\"ansi-white-fg ansi-bold\">    ^</span>\n<span class=\"ansi-red-fg ansi-bold\">IndentationError</span><span class=\"ansi-red-fg ansi-bold\">:</span> unexpected indent\n</pre>\n```\n:::\n\n:::\n:::\n\n\nIn this example, the problem is that the second line is indented by one space. But the error message points to `y`, which is misleading. Error messages indicate where the problem was discovered, but the actual error might be earlier in the code.\n\nThe same is true of runtime errors. For example, suppose you are trying to convert a ratio to decibels, like this:\n\n::: {#e64ba006 .cell execution_count=51}\n``` {.python .cell-code}\nimport math\nnumerator = 9\ndenominator = 10\nratio = numerator // denominator\ndecibels = 10 * math.log10(ratio)\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg ansi-bold\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg ansi-bold\">ValueError</span>                                Traceback (most recent call last)\nCell <span class=\"ansi-green-fg ansi-bold\">In[105], line 5</span>\n<span class=\"ansi-green-fg\">      3</span> denominator <span style=\"color:rgb(98,98,98)\">=</span> <span style=\"color:rgb(98,98,98)\">10</span>\n<span class=\"ansi-green-fg\">      4</span> ratio <span style=\"color:rgb(98,98,98)\">=</span> numerator <span style=\"color:rgb(98,98,98)\">/</span><span style=\"color:rgb(98,98,98)\">/</span> denominator\n<span class=\"ansi-green-fg ansi-bold\">----&gt; 5</span> decibels <span style=\"color:rgb(98,98,98)\">=</span> <span style=\"color:rgb(98,98,98)\">10</span> <span style=\"color:rgb(98,98,98)\">*</span> <span class=\"ansi-yellow-bg\">math</span><span style=\"color:rgb(98,98,98)\" class=\"ansi-yellow-bg\">.</span><span class=\"ansi-yellow-bg\">log10</span><span class=\"ansi-yellow-bg\">(</span><span class=\"ansi-yellow-bg\">ratio</span><span class=\"ansi-yellow-bg\">)</span>\n\n<span class=\"ansi-red-fg ansi-bold\">ValueError</span>: math domain error</pre>\n```\n:::\n\n:::\n:::\n\n\nThe error message indicates line 5, but there is nothing wrong with that line. The problem is in line 4, which uses integer division instead of floating-point division – as a result, the value of `ratio` is `0`. When we call `math.log10`, we get a `ValueError` with the message `math domain error`, because `0` is not in the \"domain\" of valid arguments for `math.log10`, because the logarithm of `0` is undefined.\n\nIn general, you should take the time to read error messages carefully, but don’t assume that everything they say is correct.\n\n---\n\nBreaking a large program into smaller functions creates natural checkpoints for debugging. If a function is not working, there are three possibilities to consider:\n\n- There is something wrong with the arguments the function is getting – that is, a precondition is violated.\n- There is something wrong with the function – that is, a postcondition is violated.\n- The caller is doing something wrong with the return value.\n\nTo rule out the first possibility, you can add a `print` statement at the beginning of the function that displays the values of the parameters (and maybe their types). Or you can write code that checks the preconditions explicitly.\n\n::: {.callout-tip}\nThis is a very basic version of [logging](https://do4ds.com/chapters/sec1/1-4-monitor-log.html).\n:::\n\nIf the parameters look good, you can add a print statement before each return statement and display the return value. If possible, call the function with arguments that make it easy check the result.\n\nIf the function seems to be working, look at the function call to make sure the return value is being used correctly – or used at all!\n\nAdding `print` statements at the beginning and end of a function can help make the flow of execution more visible for testing. For example, here is a version of `volume_of_sphere` with print statements:\n\n::: {#130b9c75 .cell execution_count=52}\n``` {.python .cell-code}\ndef volume_of_sphere(radius):\n    if type(radius) == int or type(radius) == float:\n        print(f\"Radius is a valid type: {type(radius)}\") # Showing radius is fine\n        from math import pi\n        return (4/3) * pi * radius**3\n    else:\n        print(\"Input was not a number, try again.\") # In original example, showing radius was not fine\n        return None\n```\n:::\n\n\n::: {#5abb7244 .cell execution_count=53}\n``` {.python .cell-code}\nvol = volume_of_sphere(5)\nprint(vol)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRadius is a valid type: <class 'int'>\n523.5987755982989\n```\n:::\n:::\n\n\n::: {#2f011e88 .cell execution_count=54}\n``` {.python .cell-code}\nvol = volume_of_sphere(\"5\")\nvol\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInput was not a number, try again.\n```\n:::\n:::\n\n\n## Exercises\n\n### Right-Align Text\n\nWrite a function named `print_right()` that takes a string named `text` as a parameter and prints the string with enough leading spaces that the last letter of the string is in the 40th column of the display.\n\nHint: Use `len()`, `+`, and `*`.\n\nHere's an example output:\n\n```{.python}\nprint_right(\"Monty\")\nprint_right(\"Python's\")\nprint_right(\"Flying Circus\")\n```\n\n```\n                                   Monty\n                                Python's\n                           Flying Circus\n```\n\n### Draw a Triangle\n\nWrite a function called `triangle` that takes a string and an integer, then draws a pyramid of the given height using copies of the string. For example:\n\n```{.python}\ntriangle(\"L\", 5)\n```\n\n```\nL\nLL\nLLL\nLLLL\nLLLLL\n```\n\n### Draw a Rectangle\n\nWrite a function called `rectangle` that takes a string and two integers, then draws a rectangle of the given width and height using copies of the string. For example:\n\n```{.python}\nrectangle(\"[]\", 5, 4)\n```\n\n```\n[][][][][]\n[][][][][]\n[][][][][]\n[][][][][]\n```\n\n### Triangle Tester\n\nWrite a function named `is_triangle` that takes three integers as arguments and returns True or False depending on whether you can form a triangle with those lengths. Use the rule:\n\n> If any of the three lengths is greater than the sum of the other two, then you cannot form a triangle. Otherwise, you can. (If the sum of two lengths equals the third, they form what is called a “degenerate” triangle.)\n\n*Hint*: Use a chained conditional.\n\n### Check \"Between\"\n\nWrite a boolean function `is_between(x, y, z)`, that returns `True` if $x < y < z$ or if $z < y < x$, and `False` otherwise.\n\n",
    "supporting": [
      "03-functions-flow-control-and-conditionals_files"
    ],
    "filters": [],
    "includes": {}
  }
}