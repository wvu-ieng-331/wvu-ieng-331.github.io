{
  "hash": "d576f983d3b12dc8154b67e414375fbd",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"04 | Strings, Lists, Dictionaries, and Tuples\"\nsubtitle: \"Understanding Core Python Data Structures and Patterns\"\nformat: html\norder: 4\n---\n\n\n\n\n## Overview\n\nIn this module, you will learn about Python’s most commonly used **data structures**: **strings**, **lists**, **dictionaries**, and **tuples**. You will also explore how to leverage **regular expressions** to search for patterns in text. Finally, you will see examples that combine these structures to solve more advanced tasks, followed by tips for debugging and practice exercises.\n\nWhy are these data structures important?\n\n- **Strings** handle textual data, which is central to user input, file processing, and general communication in software.\n- **Lists** store ordered collections, perfect for dynamic or changing sets of elements.\n- **Dictionaries** map from *keys* to *values* for fast lookups and flexible data storage.\n- **Tuples** group multiple items into a single, immutable structure (and can serve as dictionary keys).\n- **Regular expressions** simplify complex text matching and replacement tasks.\n\n## Strings\n\nStrings store text and are **immutable** sequences of characters. In Python, they form the foundation of almost all user-facing output and file processing.\n\n### A string is a sequence\n\nA **string** is a sequence of characters in a specific order. A character can be a letter, digit, punctuation mark, or whitespace. You can select any character in a string using the bracket operator:\n\n::: {#0d5ff588 .cell execution_count=1}\n``` {.python .cell-code}\nfruit = \"banana\"\nletter = fruit[1]\nletter\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n'a'\n```\n:::\n:::\n\n\nThe **index** in brackets starts at `0`, so `fruit[0]` is the first character (`'b'`), `fruit[1]` is the second character (`'a'`), and so on.\n\n::: {#61fe321e .cell execution_count=2}\n``` {.python .cell-code}\nfruit[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n'b'\n```\n:::\n:::\n\n\nYou can use variables or expressions as indices:\n\n::: {#a7dabbef .cell execution_count=3}\n``` {.python .cell-code}\ni = 1\nfruit[i+1]  # fruit[2]\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n'n'\n```\n:::\n:::\n\n\nIf you use a non-integer index, you get a `TypeError`. You can use `len()` to determine a string’s length:\n\n::: {#58dfe19c .cell execution_count=4}\n``` {.python .cell-code}\nn = len(fruit)  # 6 for \"banana\"\n```\n:::\n\n\nBecause indices start at `0`, the last character is at position `len(fruit) - 1`, which is `fruit[n-1]`. Alternatively, negative indices let you count backward:\n\n::: {#dc8d6ff3 .cell execution_count=5}\n``` {.python .cell-code}\nprint(fruit[-1])  # last character\nprint(fruit[-2])  # second to last\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na\nn\n```\n:::\n:::\n\n\nYou can quickly access any position in the string without manual loops.\n\n### String slices\n\nA **slice** selects a substring by indicating a range of indices with `[start:end]`. It includes the `start` index but excludes the `end`.\n\n::: {#50ef36f0 .cell execution_count=6}\n``` {.python .cell-code}\nfruit = 'banana'\nprint(fruit[0:3])  # 'ban'\nprint(fruit[3:6])  # 'ana'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nban\nana\n```\n:::\n:::\n\n\nOmitting `start` means \"from the beginning\", and omitting `end` means \"to the end\":\n\n::: {#b1e7959e .cell execution_count=7}\n``` {.python .cell-code}\nprint(fruit[:3])   # 'ban'\nprint(fruit[3:])   # 'ana'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nban\nana\n```\n:::\n:::\n\n\nIf the first index is greater than or equal to the second, you get an empty string. For example, `fruit[3:3]` returns `''`.\n\nUse slices to easily extract segments of text, such as prefixes, suffixes, or partial filenames.\n\n### Strings are immutable\n\nStrings are **immutable**, so you cannot modify them in place. An assignment like `greeting[0] = 'J'` causes a `TypeError`. Instead, create a new string:\n\n::: {#27728b8d .cell execution_count=8}\n``` {.python .cell-code}\ngreeting = 'Hello, world!'\nnew_greeting = 'J' + greeting[1:]\n```\n:::\n\n\nThis prevents accidental data corruption, making string handling more predictable.\n\n### String comparison\n\nYou can compare strings using **relational operators**:\n\n::: {#acbee8c4 .cell execution_count=9}\n``` {.python .cell-code}\nword = 'banana'\n\nif word == 'banana':\n    print('All right, banana.')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAll right, banana.\n```\n:::\n:::\n\n\nOther operators let you determine alphabetical ordering:\n\n::: {#06b0fe0f .cell execution_count=10}\n``` {.python .cell-code}\ndef compare_word(word):\n    if word < 'banana':\n        print(word, 'comes before banana.')\n    elif word > 'banana':\n        print(word, 'comes after banana.')\n    else:\n        print('All right, banana.')\n\ncompare_word(\"apple\")\ncompare_word(\"Orange\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\napple comes before banana.\nOrange comes before banana.\n```\n:::\n:::\n\n\nUppercase letters come before lowercase letters in Python’s default sort order, so be mindful of case differences. You can convert strings to lowercase or uppercase for case-insensitive comparisons.\n\n### String methods\n\nA **method** is like a function but follows the object-dot-method syntax. For example:\n\n::: {#7803e9eb .cell execution_count=11}\n``` {.python .cell-code}\ntext = \"Hello World\"\nprint(text.lower())\nprint(text.upper())\nprint(text.replace(\"Hello\", \"Hi\"))\nprint(text.split())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhello world\nHELLO WORLD\nHi World\n['Hello', 'World']\n```\n:::\n:::\n\n\nThese help easily perform text transformations for data cleaning or user-facing output.\n\n### Regular expressions\n\n**Regular expressions** (regex) help you search for complex patterns in text. Python’s built-in `re` module provides powerful tools for matching and manipulating text. \n\nFor example, you can verify formats (phone numbers, emails), capture specific bits of text, or do advanced replacements.\n\n#### A simple search example\n\n::: {#8117d6e6 .cell execution_count=12}\n``` {.python .cell-code}\nimport re\n\ntext = \"Hello, my name is Jane. It's nice to meet you.\"\npattern = 'Jane'\n\nresult = re.search(pattern, text)\nif result:\n    print(\"Found:\", result.group())\nelse:\n    print(\"Not found.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFound: Jane\n```\n:::\n:::\n\n\n- If the pattern is found, `re.search` returns a **Match** object with `.group()`, `.span()`, etc.\n- If not found, it returns `None`.\n\nThis allows very fast pattern matching in large strings, flexible for partial matches (e.g., 'Jan[eE]*' to allow slight variations).\n\n#### Using raw strings\n\nWhen writing regex, prefix patterns with `r` to create raw strings, which interpret backslashes literally:\n\n::: {#4af9ae67 .cell execution_count=13}\n``` {.python .cell-code}\nnormal_str = \"Hello\\nWorld\"  # \\n is a newline\nraw_str = r\"Hello\\nWorld\"    # keeps the literal \\n\n\nprint(normal_str)\nprint(raw_str)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello\nWorld\nHello\\nWorld\n```\n:::\n:::\n\n\nPrefix strings with `r` to avoid having to escape backslashes, e.g. `r\"\\d+\"` instead of `\"\\\\d+\"`.\n\n#### Searching in a file\n\nFor the following examples, we will use this file:\n\n::: {#27f9492b .cell execution_count=14}\n``` {.python .cell-code}\nfor line in open('data/sample_text.txt'):\n    print(line)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, world!\n\nAlice smiled as she greeted Bob with a cheerful hello.\n\nIn the quiet morning, Bob whispered hello to the sleeping world.\n\nAlice and Bob wandered through a world that seemed to echo with hello.\n\nA simple hello from Alice brightened Bobâ€™s day in an ordinary world.\n\nBob called out, \"Hello, Alice!\" as they explored the world together.\n\nIn a magical world, hello was the key that united Alice and Bob.\n\nAlice thought, \"Hello to a new day in this ever-changing world,\" as Bob nodded.\n\nWith a friendly hello, Bob opened the door to Aliceâ€™s mysterious world.\n\nThe world felt lighter when Alice and Bob exchanged a heartfelt hello.\n\nBob wrote in his journal: \"Today, Alice said hello to the whole world.\"\n\nAmid the busy city, a quiet hello from Alice and Bob brought calm to the world.\n\nIn the realm of dreams, Alice and Bob discovered that every hello sparked wonder in the world.\n\nA warm hello from Bob melted the chill of the early world, as Alice looked on.\n\nAlice and Bob laughed together, their hello echoing through the vibrant world.\n\nWhile strolling through the park, Bobâ€™s spontaneous hello made the world seem friendlier to Alice.\n\nIn a story of friendship, every hello by Alice and every nod from Bob transformed their little world.\n\nThe world listened as Bob said hello, while Alice beamed in response.\n\nUnder the starlight, Alice and Bob shared a soft hello that warmed their world.\n\nA final hello from Alice to Bob closed a day where the world felt wonderfully alive.\n\n```\n:::\n:::\n\n\nYou might loop over each line in a file and call `re.search`:\n\n::: {#a42c9ba8 .cell execution_count=15}\n``` {.python .cell-code}\ndef find_first(pattern, filename='data/sample_text.txt'):\n    import re\n    for line in open(filename):\n        result = re.search(pattern, line)\n        if result is not None:\n            return result\n\nfind_first(\"Hello\")\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n<re.Match object; span=(0, 5), match='Hello'>\n```\n:::\n:::\n\n\n#### Using the \"OR\" operator (`|`)\n\nUse the | symbol for logical OR within a regex. For example, to find either \"Alice\" or \"Bob\":\n\n::: {#65a6ca5c .cell execution_count=16}\n``` {.python .cell-code}\npattern = 'Alice|Bob'\nresult = find_first(pattern)\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<re.Match object; span=(0, 5), match='Alice'>\n```\n:::\n:::\n\n\nYou can also loop through lines, counting matches. For instance:\n\n::: {#cb1a24c6 .cell execution_count=17}\n``` {.python .cell-code}\ndef count_matches(pattern, filename='data/sample_text.txt'):\n    import re\n    count = 0\n    for line in open(filename):\n        if re.search(pattern, line) is not None:\n            count += 1\n    return count\n\nmentions = count_matches('Alice|Bob')\nprint(mentions)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n19\n```\n:::\n:::\n\n\n#### Matching start/end of lines\n\n- `^`: start of a line\n- `$`: end of a line\n\n::: {#e5c6f324 .cell execution_count=18}\n``` {.python .cell-code}\nfind_first('^Hello')\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n<re.Match object; span=(0, 5), match='Hello'>\n```\n:::\n:::\n\n\n::: {#ba7c2ec8 .cell execution_count=19}\n``` {.python .cell-code}\nfind_first('world!$')\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n<re.Match object; span=(7, 13), match='world!'>\n```\n:::\n:::\n\n\n#### More on regex syntax\n\nRegex includes special metacharacters and quantifiers:\n\n- `.` matches any character (except newline).\n- `*` matches 0 or more of the preceding element.\n- `+` matches 1 or more of the preceding element.\n- `?` makes the preceding element optional (0 or 1).\n- `[...]` matches any one character in the brackets.\n- `(...)` captures the matched text as a group.\n- `\\` escapes special characters or denotes special sequences like \\d, \\s, etc.\n\n#### String substitution\n\nUse `re.sub(pattern, replacement, text)` to substitute matches:\n\n::: {#ea8f8024 .cell execution_count=20}\n``` {.python .cell-code}\ntext_line = \"This is the centre of the city.\"\npattern = r'cent(er|re)'\nupdated_line = re.sub(pattern, 'center', text_line)\nprint(updated_line)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThis is the center of the city.\n```\n:::\n:::\n\n\nThis allows you to clean up strings in powerful ways, such as normalizing different spellings or removing special characters.\n\nUse `re.findall` to get all matches, `re.split` to split a string by a regex, and various flags (e.g., `re.IGNORECASE`) to alter matching behavior.\n\nRegex is extremely powerful for tasks like extracting email addresses, validating formats, or searching logs.\n\n## Lists\n\nLists are **mutable** sequences that can store elements of any type (including other lists). They form the workhorse for many data-processing tasks due to their flexibility.\n\n### A list is a sequence\n\nA **list** is a sequence of values (of any type). Create one with square brackets:\n\n::: {#bcccd017 .cell execution_count=21}\n``` {.python .cell-code}\nnumbers = [42, 123]\ncheeses = ['Cheddar', 'Edam', 'Gouda']\nmixed = ['spam', 2.0, 5, [10, 20]]  # nested list\nempty = []\n```\n:::\n\n\n`len(cheeses)` returns the length of a list. The length of an empty list is `0`.\n\n### Lists are mutable\n\nUse the bracket operator to read or write an element:\n\n::: {#14087179 .cell execution_count=22}\n``` {.python .cell-code}\nnumbers[1] = 17  # modifies the list\nprint(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[42, 17]\n```\n:::\n:::\n\n\nUnlike strings, lists allow you to assign directly to their indices. You can still use negative indices to count backward.\n\nUse the `in` operator to check membership:\n\n::: {#3400e273 .cell execution_count=23}\n``` {.python .cell-code}\n'Edam' in cheeses\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\nTrue\n```\n:::\n:::\n\n\n### List slices\n\nLists support slicing with the same `[start:end]` syntax as strings:\n\n::: {#c9afb4eb .cell execution_count=24}\n``` {.python .cell-code}\nletters = ['a', 'b', 'c', 'd']\n```\n:::\n\n\n::: {#002096df .cell execution_count=25}\n``` {.python .cell-code}\nletters[1:3]\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n['b', 'c']\n```\n:::\n:::\n\n\n::: {#d501a29b .cell execution_count=26}\n``` {.python .cell-code}\nletters[:2]\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n['a', 'b']\n```\n:::\n:::\n\n\n::: {#08d9aa1f .cell execution_count=27}\n``` {.python .cell-code}\nletters[2:]\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n['c', 'd']\n```\n:::\n:::\n\n\n::: {#e770bc0a .cell execution_count=28}\n``` {.python .cell-code}\nletters[:] # copy of the list\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n['a', 'b', 'c', 'd']\n```\n:::\n:::\n\n\n### List operations\n\n`+` concatenates, `*` repeats:\n\n::: {#8d6a8131 .cell execution_count=29}\n``` {.python .cell-code}\n[1, 2] + [3, 4] \n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n[1, 2, 3, 4]\n```\n:::\n:::\n\n\n::: {#6dfcecd9 .cell execution_count=30}\n``` {.python .cell-code}\n['spam'] * 4\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\n['spam', 'spam', 'spam', 'spam']\n```\n:::\n:::\n\n\n::: {#b032eaba .cell execution_count=31}\n``` {.python .cell-code}\nsum([1, 2, 3])\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\n6\n```\n:::\n:::\n\n\n::: {#c12117e2 .cell execution_count=32}\n``` {.python .cell-code}\nmin([3, 1, 4])\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n1\n```\n:::\n:::\n\n\n::: {#db165d4a .cell execution_count=33}\n``` {.python .cell-code}\nmax([3, 1, 4])\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n4\n```\n:::\n:::\n\n\n### List methods\n\n- `append(x)` adds an item at the end.\n- `extend([x, y])` adds multiple items.\n- `pop(index)` removes and returns the item at `index`.\n- `remove(x)` removes the first occurrence of `x`.\n\n::: {#eb38a893 .cell execution_count=34}\n``` {.python .cell-code}\nletters = ['a', 'b', 'c']\n```\n:::\n\n\n::: {#f23d93f6 .cell execution_count=35}\n``` {.python .cell-code}\nletters.append('d')      # modifies letters\nprint(letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['a', 'b', 'c', 'd']\n```\n:::\n:::\n\n\n::: {#cde4f5f4 .cell execution_count=36}\n``` {.python .cell-code}\nletters.extend(['e', 'f'])\nprint(letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['a', 'b', 'c', 'd', 'e', 'f']\n```\n:::\n:::\n\n\n::: {#0b48c2d8 .cell execution_count=37}\n``` {.python .cell-code}\nletters.pop(1)           # removes 'b'\nprint(letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['a', 'c', 'd', 'e', 'f']\n```\n:::\n:::\n\n\n::: {#f8cebb68 .cell execution_count=38}\n``` {.python .cell-code}\nletters.remove('e')      # removes 'e'\nprint(letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['a', 'c', 'd', 'f']\n```\n:::\n:::\n\n\nThese list methods help manage growing or shrinking lists without extra variables.\n\n---\n\nList methods often modify a list **in place** and return `None`. This can confuse people who expect them to behave like string methods. For instance:\n\n::: {#520aa8ff .cell execution_count=39}\n``` {.python .cell-code}\nt = [1, 2, 3]\nt = t.remove(3)  # WRONG!\n\nprint(t)\n# Expect: [1, 2]\n# Return: None\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNone\n```\n:::\n:::\n\n\n`remove(3)` modifies `t` and returns `None`, so assigning it back to `t` loses the original list. If you see an error like `NoneType object has no attribute 'remove'`, check whether you accidentally assigned a list method’s return value to the list.\n\nFor the example above, you would do this:\n\n::: {#cbe28ad0 .cell execution_count=40}\n``` {.python .cell-code}\nt = [1, 2, 3]\nt.remove(3)  # CORRECT!\n\nprint(t)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2]\n```\n:::\n:::\n\n\n### Lists and strings\n\na **list of characters** is not the same as a **string**. To convert a string to a list of characters, use `list()`:\n\n::: {#fcba5d39 .cell execution_count=41}\n``` {.python .cell-code}\ns = 'coal'\nt = list(s)\nprint(t)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['c', 'o', 'a', 'l']\n```\n:::\n:::\n\n\nTo split a string by whitespace into a list of words:\n\n::: {#9fd40e15 .cell execution_count=42}\n``` {.python .cell-code}\ns = \"The children yearn for the mines\"\nwords = s.split()\nprint(words)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['The', 'children', 'yearn', 'for', 'the', 'mines']\n```\n:::\n:::\n\n\nYou can specify a delimiter for `split`, and you can use `''.join(list_of_strings)` to rebuild a single string from a list. These are useful for text tokenization, splitting logs, or reconstructing messages.\n\n### Looping through a list\n\na `for` loop iterates over each element:\n\n::: {#e7426299 .cell execution_count=43}\n``` {.python .cell-code}\nfor cheese in cheeses:\n    print(cheese)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCheddar\nEdam\nGouda\n```\n:::\n:::\n\n\n### Sorting lists\n\nUse `sorted()` to return a new sorted list without modifying the original:\n\n::: {#9aa30354 .cell execution_count=44}\n``` {.python .cell-code}\nscrambled_list = [\"c\", \"a\", \"b\"]\nsorted_list = sorted(scrambled_list)\n\nprint(sorted_list)\nprint(scrambled_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['a', 'b', 'c']\n['c', 'a', 'b']\n```\n:::\n:::\n\n\n`sorted('letters')` returns a list of characters. Combine with `\"\".join()` to build a sorted string:\n\n::: {#36b4ba84 .cell execution_count=45}\n``` {.python .cell-code}\n\"\".join(sorted('letters'))\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```\n'eelrstt'\n```\n:::\n:::\n\n\n### Objects and values\n\nVariables can refer to the same **object** or different objects that have the same **value**. For example:\n\n::: {#2e74c91d .cell execution_count=46}\n``` {.python .cell-code}\na = 'banana'\nb = 'banana'\na is b  # often True (same object)\n```\n\n::: {.cell-output .cell-output-display execution_count=46}\n```\nTrue\n```\n:::\n:::\n\n\nIn this example, Python only created one string object, and both `a` and `b` refer to it. But when you create two lists, you get two objects.\n\n::: {#1d3edc09 .cell execution_count=47}\n``` {.python .cell-code}\nx = [1, 2, 3]\ny = [1, 2, 3]\nx is y  # False (different objects)\n```\n\n::: {.cell-output .cell-output-display execution_count=47}\n```\nFalse\n```\n:::\n:::\n\n\nIn this case we would say that the two lists are **equivalent**, because they have the same elements, but not **identical**, because they are not the same object. If two objects are identical, they are also equivalent, but if they are equivalent, they are not necessarily identical.\n\n### Aliasing\n\nWhen you assign one variable to another, both variables **reference** the same object:\n\n::: {#59b8d68e .cell execution_count=48}\n``` {.python .cell-code}\na = [1, 2, 3]\nb = a\nb is a\n```\n\n::: {.cell-output .cell-output-display execution_count=48}\n```\nTrue\n```\n:::\n:::\n\n\nIf an object is mutable, changes made via one variable affect the other:\n\n::: {#19b6c834 .cell execution_count=49}\n``` {.python .cell-code}\nprint(a)\nb[0] = 5\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3]\n[5, 2, 3]\n```\n:::\n:::\n\n\nAvoid aliasing unless it’s intentional.\n\n### List arguments\n\nWhen you pass a list to a function, you pass a reference to that list. The function can modify the original list:\n\n::: {#d2dfdab4 .cell execution_count=50}\n``` {.python .cell-code}\ndef pop_first(lst):\n    return lst.pop(0)\n\nletters = ['a', 'b', 'c']\npop_first(letters)\nprint(letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['b', 'c']\n```\n:::\n:::\n\n\nIf you do not want a function to modify the original list, pass a copy:\n\n::: {#da52f5fa .cell execution_count=51}\n``` {.python .cell-code}\npop_first(list(letters))  # or pop_first(letters[:])\n```\n\n::: {.cell-output .cell-output-display execution_count=51}\n```\n'b'\n```\n:::\n:::\n\n\n## Dictionaries\n\nA **dictionary** maps keys to values and offers very fast lookups. Keys must be *immutable*, while values can be anything (including lists).\n\n### A dictionary is a mapping\n\nInstead of using integer indices, a dictionary can use almost any **hashable** type as a **key**. You create a dictionary with curly braces:\n\n::: {#beb5f755 .cell execution_count=52}\n``` {.python .cell-code}\nnumbers = {}\nnumbers['zero'] = 0\nnumbers['one'] = 1\nnumbers\n```\n\n::: {.cell-output .cell-output-display execution_count=52}\n```\n{'zero': 0, 'one': 1}\n```\n:::\n:::\n\n\nAccess a value using its key:\n\n::: {#d48cbdf6 .cell execution_count=53}\n``` {.python .cell-code}\nnumbers['one']\n```\n\n::: {.cell-output .cell-output-display execution_count=53}\n```\n1\n```\n:::\n:::\n\n\nDictionary keys must be unique and immutable. Lists cannot serve as keys because they are mutable. These are useful for fast lookup by label (e.g., “user_id” -> user info) instead of by integer position.\n\n### Creating dictionaries\n\nYou can create a dictionary all at once:\n\n::: {#30388bbf .cell execution_count=54}\n``` {.python .cell-code}\nnumbers = {'zero': 0, 'one': 1, 'two': 2}\n```\n:::\n\n\nor use `dict()`:\n\n::: {#c3e37299 .cell execution_count=55}\n``` {.python .cell-code}\nnumbers_copy = dict(numbers)\nprint(numbers_copy)\n\nempty = dict()\nprint(empty)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'zero': 0, 'one': 1, 'two': 2}\n{}\n```\n:::\n:::\n\n\n### The `in` operator\n\n`in` checks for keys in the dictionary for membership without searching through all entries:\n\n::: {#442e4176 .cell execution_count=56}\n``` {.python .cell-code}\n'one' in numbers\n```\n\n::: {.cell-output .cell-output-display execution_count=56}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#ead57c53 .cell execution_count=57}\n``` {.python .cell-code}\n'three' in numbers\n```\n\n::: {.cell-output .cell-output-display execution_count=57}\n```\nFalse\n```\n:::\n:::\n\n\nTo check if something appears as a **value**, use `numbers.values()`:\n\n::: {#1f62617a .cell execution_count=58}\n``` {.python .cell-code}\n1 in numbers.values()\n```\n\n::: {.cell-output .cell-output-display execution_count=58}\n```\nTrue\n```\n:::\n:::\n\n\n### Counting with dictionaries\n\nUse a dictionary to count how often each character appears in a string:\n\n::: {#a82163b2 .cell execution_count=59}\n``` {.python .cell-code}\ndef value_counts(string):\n    counter = {}\n    for letter in string:\n        if letter not in counter:\n            counter[letter] = 1\n        else:\n            counter[letter] += 1\n    return counter\n\nvalue_counts('brontosaurus')\n```\n\n::: {.cell-output .cell-output-display execution_count=59}\n```\n{'b': 1, 'r': 2, 'o': 2, 'n': 1, 't': 1, 's': 2, 'a': 1, 'u': 2}\n```\n:::\n:::\n\n\n### Looping with dictionaries\n\nWhen you loop over a dictionary, you traverse its keys:\n\n::: {#998991d0 .cell execution_count=60}\n``` {.python .cell-code}\ncounter = value_counts('banana')\n```\n:::\n\n\n::: {#41cd9895 .cell execution_count=61}\n``` {.python .cell-code}\nfor key in counter:\n    print(key)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nb\na\nn\n```\n:::\n:::\n\n\nUse `counter.values()` to loop over values:\n\n::: {#302021b2 .cell execution_count=62}\n``` {.python .cell-code}\nfor value in counter.values():\n    print(value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n3\n2\n```\n:::\n:::\n\n\nOr you can use the bracket operator to get the key and value:\n\n::: {#b008ff0d .cell execution_count=63}\n``` {.python .cell-code}\nfor key in counter:\n    print(key, counter[key])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nb 1\na 3\nn 2\n```\n:::\n:::\n\n\nThis method searches the `counter` dictionary in every loop, and we will see more efficient version of this loop in the tuples section.\n\n### Lists and dictionaries\n\nA dictionary’s **values** can be lists (or other dictionaries), but keys must be hashable:\n\n::: {#894c33da .cell execution_count=64}\n``` {.python .cell-code}\nd = {\n    \"fruits\": [\"apple\", \"banana\", \"cherry\"],\n    \"numbers\": [10, 20, 30],\n    \"colors\": {\n        \"red\": [True, False, True],\n        \"yellow\": [True, True, False],\n        \"green\": [True, False, False]\n    }\n}\n\nprint(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'fruits': ['apple', 'banana', 'cherry'], 'numbers': [10, 20, 30], 'colors': {'red': [True, False, True], 'yellow': [True, True, False], 'green': [True, False, False]}}\n```\n:::\n:::\n\n\nThis allows you to combine structures for more complex data representations, such as JSON-like objects. **You cannot use a list as a key**. Python uses a **hash table** for quick lookups, and hash values must not change.\n\n## Tuples\n\nTuples are immutable sequences that can hold multiple items. They’re often used where immutability is helpful (e.g., as dictionary keys).\n\n### Tuples are sequences\n\nTuples work like lists but cannot be modified once created. You create a tuple with comma-separated values, usually enclosed in parentheses:\n\n::: {#79c393a8 .cell execution_count=65}\n``` {.python .cell-code}\nt = ('l', 'u', 'p', 'i', 'n')\nt_2 = 'l', 'u', 'p', 'i', 'n'\n\nprint(type(t))\nprint(type(t_2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'tuple'>\n<class 'tuple'>\n```\n:::\n:::\n\n\nYou can create a single element tuple:\n\n::: {#9057fe60 .cell execution_count=66}\n``` {.python .cell-code}\nt_single = \"a\",\nprint(t_single)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n('a',)\n```\n:::\n:::\n\n\nWrapping a single element with parenthesis does not make a single-element tuple:\n\n::: {#1bcfc1d0 .cell execution_count=67}\n``` {.python .cell-code}\nt_single_bad = (\"a\")\nprint(t_single_bad)\nprint(type(t_single_bad))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na\n<class 'str'>\n```\n:::\n:::\n\n\n### Tuples are immutable\n\nLike strings, tuples are **immutable**. Attempting to modify a tuple directly causes an error. Tuples do not have list-like methods such as `append` or `remove`.\n\n::: {#054b28c7 .cell execution_count=68}\n``` {.python .cell-code}\nt[0] = \"L\"\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg ansi-bold\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg ansi-bold\">TypeError</span>                                 Traceback (most recent call last)\nCell <span class=\"ansi-green-fg ansi-bold\">In[68], line 1</span>\n<span class=\"ansi-green-fg ansi-bold\">----&gt; 1</span> <span class=\"ansi-yellow-bg\">t</span><span class=\"ansi-yellow-bg\">[</span><span style=\"color:rgb(98,98,98)\" class=\"ansi-yellow-bg\">0</span><span class=\"ansi-yellow-bg\">]</span> <span style=\"color:rgb(98,98,98)\">=</span> <span style=\"color:rgb(175,0,0)\">\"</span><span style=\"color:rgb(175,0,0)\">L</span><span style=\"color:rgb(175,0,0)\">\"</span>\n\n<span class=\"ansi-red-fg ansi-bold\">TypeError</span>: 'tuple' object does not support item assignment</pre>\n```\n:::\n\n:::\n:::\n\n\nBecause they are immutable, tuples are **hashable** and can serve as keys in a dictionary:\n\n::: {#a82cdeeb .cell execution_count=69}\n``` {.python .cell-code}\ncoords = {}\ncoords[(1, 2)] = \"Location A\"\ncoords[(3, 4)] = \"Location B\"\nprint(coords)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{(1, 2): 'Location A', (3, 4): 'Location B'}\n```\n:::\n:::\n\n\nYou cannot alter tuple contents after creation.\n\n### Tuple assignment\n\nYou can assign multiple variables at once with tuple unpacking:\n\n::: {#edf2f143 .cell execution_count=70}\n``` {.python .cell-code}\na, b = 1, 2 # could also use: (a, b) = (1, 2) or any combo of parenthesis\nprint(a, b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 2\n```\n:::\n:::\n\n\nIf the right side has the wrong number of values, Python raises a `ValueError`. \n\n::: {#d14ca1fe .cell execution_count=71}\n``` {.python .cell-code}\na, b = 1, 2, 3\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg ansi-bold\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg ansi-bold\">ValueError</span>                                Traceback (most recent call last)\nCell <span class=\"ansi-green-fg ansi-bold\">In[71], line 1</span>\n<span class=\"ansi-green-fg ansi-bold\">----&gt; 1</span> a, b <span style=\"color:rgb(98,98,98)\">=</span> <span style=\"color:rgb(98,98,98)\">1</span>, <span style=\"color:rgb(98,98,98)\">2</span>, <span style=\"color:rgb(98,98,98)\">3</span>\n\n<span class=\"ansi-red-fg ansi-bold\">ValueError</span>: too many values to unpack (expected 2)</pre>\n```\n:::\n\n:::\n:::\n\n\nYou can also swap variables in one line. This allows you to swap variables without an extra temporary variable and return multiple values elegantly:\n\n::: {#948f369e .cell execution_count=72}\n``` {.python .cell-code}\nprint(a, b)\na, b = b, a # swap\nprint(a, b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 2\n2 1\n```\n:::\n:::\n\n\nYou often use tuple assignment to iterate over `(key, value)` pairs from a dictionary:\n\n::: {#24449a61 .cell execution_count=73}\n``` {.python .cell-code}\nd = {'one': 1, 'two': 2, 'three': 3}\n\nfor item in d.items():\n    key, value = item\n    print(key, '->', value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\none -> 1\ntwo -> 2\nthree -> 3\n```\n:::\n:::\n\n\nEach time through the loop, `item` is assigned a tuple that contains a key and the corresponding value.\n\nWe can write this loop more concisely, like this:\n\n::: {#742a73e3 .cell execution_count=74}\n``` {.python .cell-code}\nfor key, value in d.items():\n    print(key, '->', value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\none -> 1\ntwo -> 2\nthree -> 3\n```\n:::\n:::\n\n\n### Tuples as return values\n\nA function can return a single tuple, effectively returning multiple values:\n\n::: {#5eefc2ca .cell execution_count=75}\n``` {.python .cell-code}\ndef min_max(t):\n    return min(t), max(t) # could also write: (min(t), max(t))\n\nlow, high = min_max([2, 4, 1, 3])\nprint(low, high)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 4\n```\n:::\n:::\n\n\nThis offers a clean way to return more than one piece of information from a function.\n\n### Argument packing and unpacking\n\nIf a function parameter starts with `*`, Python **packs** extra arguments into a tuple:\n\n::: {#900ff612 .cell execution_count=76}\n``` {.python .cell-code}\ndef mean(*args):\n    return sum(args) / len(args)\n\nmean(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=76}\n```\n2.0\n```\n:::\n:::\n\n\nHere is an example you are already familiar with, `print`:\n\n```{.python}\ndef print(*args, sep=' ', end='\\n', file=None, flush=False):\n    \"\"\"print code\"\"\"\n```\n\n::: {#f7742caa .cell execution_count=77}\n``` {.python .cell-code}\nprint(1, 2, 3, sep=\", \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1, 2, 3\n```\n:::\n:::\n\n\nYou can **unpack** a sequence by using `*` when calling a function:\n\n::: {#52f26bb6 .cell execution_count=78}\n``` {.python .cell-code}\ndivmod(*[7, 3])  # same as divmod(7, 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=78}\n```\n(2, 1)\n```\n:::\n:::\n\n\nConsider a function that calculates a “trimmed” mean by removing the lowest and highest values:\n\n::: {#f605e044 .cell execution_count=79}\n``` {.python .cell-code}\ndef trimmed_mean(*args):\n    low, high = min_max(args)\n    trimmed = list(args)\n    trimmed.remove(low)\n    trimmed.remove(high)\n    return mean(*trimmed)\n\ntrimmed_mean(1, 2, 3, 4, 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=79}\n```\n3.0\n```\n:::\n:::\n\n\nWhile this is a bit more advanced than we will need for this course, it allows flexible argument passing and returning, which helps build utility functions that accept varying numbers of inputs.\n\n### Zip\n\nThe built-in `zip` function pairs up corresponding elements from multiple sequences:\n\n::: {#ec8a0520 .cell execution_count=80}\n``` {.python .cell-code}\nscores1 = [1, 2, 4, 5, 1, 5, 2]\nscores2 = [5, 5, 2, 5, 5, 2, 3]\n\nfor s1, s2 in zip(scores1, scores2):\n    if s1 > s2:\n        print(\"Team1 wins this game!\")\n    elif s1 < s2:\n        print(\"Team2 wins this game!\")\n    else:\n        print(\"It's a tie!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTeam2 wins this game!\nTeam2 wins this game!\nTeam1 wins this game!\nIt's a tie!\nTeam2 wins this game!\nTeam1 wins this game!\nTeam2 wins this game!\n```\n:::\n:::\n\n\n`list(zip(a, b))` returns a list of tuples. You can also combine `zip` with `dict` to create dictionaries from two parallel lists:\n\n::: {#9746f423 .cell execution_count=81}\n``` {.python .cell-code}\nletters = 'abc'\nnumbers = [0, 1, 2]\ndict(zip(letters, numbers)) # try list(zip(letters, numbers)) on your own\n```\n\n::: {.cell-output .cell-output-display execution_count=81}\n```\n{'a': 0, 'b': 1, 'c': 2}\n```\n:::\n:::\n\n\nUse `enumerate` to loop over the indices and elements of a sequence at the same time:\n\n::: {#8fe1c34d .cell execution_count=82}\n``` {.python .cell-code}\nfor index, element in enumerate('abcefghijk'):\n    print(index, element)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0 a\n1 b\n2 c\n3 e\n4 f\n5 g\n6 h\n7 i\n8 j\n9 k\n```\n:::\n:::\n\n\nTo see the values `enumerate` creates, you need to turn the `enumerate` object into either a list, tuple, or dictionary:\n\n::: {#051dedf9 .cell execution_count=83}\n``` {.python .cell-code}\nenumerate('abcefghijk')\n```\n\n::: {.cell-output .cell-output-display execution_count=83}\n```\n<enumerate at 0x1f1af060180>\n```\n:::\n:::\n\n\n::: {#4f6486a3 .cell execution_count=84}\n``` {.python .cell-code}\nlist(enumerate('abcefghijk'))\n```\n\n::: {.cell-output .cell-output-display execution_count=84}\n```\n[(0, 'a'),\n (1, 'b'),\n (2, 'c'),\n (3, 'e'),\n (4, 'f'),\n (5, 'g'),\n (6, 'h'),\n (7, 'i'),\n (8, 'j'),\n (9, 'k')]\n```\n:::\n:::\n\n\n::: {#514a8558 .cell execution_count=85}\n``` {.python .cell-code}\ntuple(enumerate('abcefghijk'))\n```\n\n::: {.cell-output .cell-output-display execution_count=85}\n```\n((0, 'a'),\n (1, 'b'),\n (2, 'c'),\n (3, 'e'),\n (4, 'f'),\n (5, 'g'),\n (6, 'h'),\n (7, 'i'),\n (8, 'j'),\n (9, 'k'))\n```\n:::\n:::\n\n\n::: {#3a8b6d09 .cell execution_count=86}\n``` {.python .cell-code}\ndict(enumerate('abcefghijk'))\n```\n\n::: {.cell-output .cell-output-display execution_count=86}\n```\n{0: 'a',\n 1: 'b',\n 2: 'c',\n 3: 'e',\n 4: 'f',\n 5: 'g',\n 6: 'h',\n 7: 'i',\n 8: 'j',\n 9: 'k'}\n```\n:::\n:::\n\n\nThis is true for many Python functions that create objects, so remember to experiment with new code.\n\n### Inverting a dictionary\n\nTo invert a dictionary that maps a key to a value, you might need to map each value to a list of keys (because multiple keys can share the same value). For example:\n\n::: {#096f50e2 .cell execution_count=87}\n``` {.python .cell-code}\ndef invert_dict(d):\n    new_d = {}\n    for key, val in d.items():\n        if val not in new_d:\n            new_d[val] = [key]\n        else:\n            new_d[val].append(key)\n    return new_d\n```\n:::\n\n\nThis is useful for reverse lookups when multiple keys share the same value:\n\n::: {#858a2eed .cell execution_count=88}\n``` {.python .cell-code}\ncounts = {\n    \"a\": 1,\n    \"b\": 23,\n    \"c\": 1,\n    \"d\": 4,\n    \"e\": 4\n}\n\ninvert_dict(counts)\n```\n\n::: {.cell-output .cell-output-display execution_count=88}\n```\n{1: ['a', 'c'], 23: ['b'], 4: ['d', 'e']}\n```\n:::\n:::\n\n\n### Dictionaries with tuple keys\n\nTuples are hashable, so we can use them as dictionary keys:\n\n::: {#6375aba3 .cell execution_count=89}\n``` {.python .cell-code}\nlocations = {}\nlocations[(1, 2)] = \"Start\"\nlocations[(3, 4)] = \"Goal\"\nprint(locations[(3, 4)]) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGoal\n```\n:::\n:::\n\n\nThis could be useful for coordinate-based lookups (e.g., board games or grid-based apps).\n\n##  Exercises\n\n### Checking for a word in a sentence\n\nWrite a program that checks if the word `\"apple\"` appears in the sentence \"`I bought some apples and oranges at the market.\"` Print `\"Found\"` or `\"Not Found\"` accordingly. Consider using `re.search()` with a pattern allowing an optional `s`.\n\n### Finding phone numbers with different formats\n\nGiven:\n\n::: {#b69549e6 .cell execution_count=90}\n``` {.python .cell-code}\ntext = \"\"\"\nCall me at 123-456-7890 or at (123) 456-7890.\nAlternatively, reach me at 123.456.7890.\n\"\"\"\n```\n:::\n\n\nWrite a single regex that matches all three phone formats. Use `re.findall()` to capture them.\n\n### Extracting captured groups\n\nFor a product catalog:\n\n::: {#cad7b8a7 .cell execution_count=91}\n``` {.python .cell-code}\ncatalog = \"\"\"Product ID: ABC-123 Price: $29.99\nProduct ID: XY-999 Price: $199.95\nProduct ID: TT-100 Price: $10.50\nProduct ID: ZZ-777 Price: $777.00\nProduct ID: FF-333 Price: $2.99\n\"\"\"\n```\n:::\n\n\nWrite a regex that captures `(ProductID, Price)` as groups. Use `re.findall()` to produce a list of tuples.\n\n## Anagrams\n\nTwo words are anagrams if one can be rearranged to form the other. Write `is_anagram` that returns `True` if two strings are anagrams. Then find all anagrams of `\"takes\"` in a given word list.\n\n## Palindromes\n\nA palindrome reads the same forward and backward. Write `is_palindrome` that checks if a string is a palindrome. Use `reversed` or slice notation to reverse strings.\n\n## Using `get` in a dictionary\n\nRewrite the `value_counts` function to eliminate the `if` statement by using `dict.get(key, default)`.\n\n## Longest word with all unique letters\n\nWrite `has_duplicates(sequence)` that returns `True` if any element appears more than once. Test it to see if you can find a word longer than `\"unpredictably\"` with all unique letters.\n\n## Finding repeats\n\nWrite `find_repeats(counter)` that takes a dictionary mapping from keys to counts and returns a list of keys appearing more than once.\n\n## Most frequent letters\n\nWrite `most_frequent_letters(string)` that prints letters in decreasing order of frequency. You can use `reversed(sorted(...))` or `sorted(..., reverse=True)`.\n\n",
    "supporting": [
      "04-data-structures_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}